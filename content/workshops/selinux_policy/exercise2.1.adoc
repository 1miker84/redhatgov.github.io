---
title: "Exercise 2.1 - Generating a generic policy"
workshops: selinux_policy
workshop_weight: 21
layout: lab
---

:icons: font
:imagesdir: /workshops/selinux_policy/images

= Exercise 2.1 - Generating a generic policy



== Exercise Description

In this exercise, we are going to automatically generate an SELinux policy framework, and learn to handle AVC messages that are generated by SELinux, when the application violates the policy.

== Section 1: Logging into Ansible Tower and installing the license key


=== Step 1: Generate an initial generic SELinux policy

Create a policy directory, and generate an initial policy.  Use `sepolicy generate` to generate a policy for the app that we want to enable.

{{< highlight bash >}}
cd ~/src
mkdir policy
cd policy
sepolicy generate --init /usr/local/sbin/testapp
{{< /highlight >}}

Note the last few lines in the output from `sepolicy generate`:
[source,bash]
----
Created the following files:
/home/ec2-user/src/policy/testapp.te # Type Enforcement file
/home/ec2-user/src/policy/testapp.if # Interface file
/home/ec2-user/src/policy/testapp.fc # File Contexts file
/home/ec2-user/src/policy/testapp_selinux.spec # Spec file
/home/ec2-user/src/policy/testapp.sh # Setup Script
----

You will need all of these files to customize the policy, for the application.

.SELinux Policy Source Compnents
. `testapp.te` is the base policy for the application.  It sets the rules for the `testapp_t` domain
. `testapp.if` is the *interface* file.  Interfaces are like public functions, in that they provide ways for other SELinux modules to interact with the one that you are writing
. `testapp.fc` is the *file contexts* file.  It contains the labeling information for all filesystem objects that the policy references
. `testapp.sh` is a Red Hat provided script that compiles and loads the SELinux policy module

=== Step 2: Compile the policy framework

Now, compile and load the SELinux policy framework, by running the `testapp.sh` script.  The script needs to be run with *root* privileges, since it changes the running SELinux configuration:

{{< highlight bash >}}
sudo ./testapp.sh
{{< /highlight >}}

The first 9 lines of the output show the policy compilation, the loading of the policy into memory, and the automatic generation of a manpage for the policy:
[source,bash]
----
Building and Loading Policy
+ make -f /usr/share/selinux/devel/Makefile testapp.pp
Compiling targeted testapp module
/usr/bin/checkmodule:  loading policy configuration from tmp/testapp.tmp
/usr/bin/checkmodule:  policy configuration loaded
/usr/bin/checkmodule:  writing binary representation (version 19) to tmp/testapp.mod
Creating targeted testapp.pp policy package
rm tmp/testapp.mod tmp/testapp.mod.fc
+ /usr/sbin/semodule -i testapp.pp
+ sepolicy manpage -p . -d testapp_t
./testapp_selinux.8
----

In addition to compiling and loading the policy, the `testapp.sh` script also generates an RPM spec file, and builds a package, containing the policy for the app.  This makes it easy to redistribute the policy, when you have finishe dcreating it.  You can see this in the second part of the script output:

[source,bash]
----
+ /sbin/restorecon -F -R -v /usr/local/sbin/testapp
++ pwd
+ pwd=/home/ec2-user/src/policy
+ rpmbuild --define '_sourcedir /home/ec2-user/src/policy' --define '_specdir /home/ec2-user/src/policy' --define '_builddir /home/ec2-user/src/policy' --define '_srcrpmdir /home/ec2-user/src/policy' --define '_rpmdir /home/ec2-user/src/policy' --define '_buildrootdir /home/ec2-user/src/policy/.build' -ba testapp_selinux.spec
Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.8GjK3r
+ umask 022
+ cd /home/ec2-user/src/policy
+ '[' /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64 '!=' / ']'
+ rm -rf /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64
++ dirname /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64
+ mkdir -p /home/ec2-user/src/policy/.build
+ mkdir /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/usr/share/selinux/packages
+ install -m 644 /home/ec2-user/src/policy/testapp.pp /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/usr/share/selinux/packages
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/usr/share/selinux/devel/include/contrib
+ install -m 644 /home/ec2-user/src/policy/testapp.if /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/usr/share/selinux/devel/include/contrib/
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/usr/share/man/man8/
+ install -m 644 /home/ec2-user/src/policy/testapp_selinux.8 /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/usr/share/man/man8/testapp_selinux.8
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64/etc/selinux/targeted/contexts/users/
+ /usr/lib/rpm/check-buildroot
+ /usr/lib/rpm/redhat/brp-compress
+ /usr/lib/rpm/redhat/brp-strip /usr/bin/strip
+ /usr/lib/rpm/redhat/brp-strip-comment-note /usr/bin/strip /usr/bin/objdump
+ /usr/lib/rpm/redhat/brp-strip-static-archive /usr/bin/strip
+ /usr/lib/rpm/brp-python-bytecompile /usr/bin/python 1
+ /usr/lib/rpm/redhat/brp-python-hardlink
+ /usr/lib/rpm/redhat/brp-java-repack-jars
Processing files: testapp_selinux-1.0-1.el7.noarch
Provides: testapp_selinux = 1.0-1.el7
Requires(interp): /bin/sh /bin/sh
Requires(rpmlib): rpmlib(CompressedFileNames) <= 3.0.4-1 rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1
Requires(post): /bin/sh policycoreutils selinux-policy-base >= 3.13.1-229
Requires(postun): /bin/sh policycoreutils
Checking for unpackaged file(s): /usr/lib/rpm/check-files /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64
Wrote: /home/ec2-user/src/policy/testapp_selinux-1.0-1.el7.src.rpm
Wrote: /home/ec2-user/src/policy/noarch/testapp_selinux-1.0-1.el7.noarch.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.aqm3qv
+ umask 022
+ cd /home/ec2-user/src/policy
+ /usr/bin/rm -rf /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el7.x86_64
+ exit 0
----

=== Step 3: Check to see your policy in action

If we reload the application, the newly compiled and loaded policy module will be attached to it:

{{< highlight bash >}}
sudo systemctl stop testapp
sudo systemctl start testapp
ps -efZ | grep testapp | grep -v grep
{{< /highlight >}}

[source,bash]
----
system_u:system_r:testapp_t:s0  root      8737     1  0 20:51 ?        00:00:00 /usr/local/sbin/testapp
----

=== Step 4: How does the application end up with the *testapp_t* context?

This is because of SELinux domain transition rules.  The `testapp` service is started by `systemd`, which runs with a context of `init_t`, as it is our init service.  Because of the transition rules, it changes contexts when the service is launched. The rule says that any process labeled as `init_t` will execute any binary labeled as `testapp_exec_t`, the newly-created process will be labeled as `testapp_t`.

To see those rules, type this:
{{< highlight bash >}}
sesearch -T -s init_t -t testapp_exec_t
{{< /highlight >}}

[source,bash]
----
Found 1 semantic te rules:
   type_transition init_t testapp_exec_t : process testapp_t;
----

The rule says that when any process labeled as `init_t` executes any binary labeled as `testapp_exec_t`, the newly-created process will be labeled as `testapp_t`.

=== Step 5: Check for AVC denials

Now that our app is up and running, we can check the system logs for AVC (access vector cache, where SELinux caches decisions to grant or deny access) denial messages.

{{< highlight bash >}}
ausearch -m AVC -ts recent
{{< /highlight >}}

There will (and should!) be quite a few denials returned from `ausearch`.  Here are some from the example machine:

[source,bash]
-----
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.764:25971): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.764:25971): arch=c000003e syscall=2 success=yes exit=4 a0=401a32 a1=0 a2=1b6 a3=24 items=0 ppid=1 pid=1022 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.764:25971): avc:  denied  { open } for  pid=1022 comm="testapp" path="/proc/meminfo" dev="proc" ino=4026532040 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:proc_t:s0 tclass=file permissive=1
type=AVC msg=audit(1552588580.764:25971): avc:  denied  { read } for  pid=1022 comm="testapp" name="meminfo" dev="proc" ino=4026532040 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:proc_t:s0 tclass=file permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.764:25972): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.764:25972): arch=c000003e syscall=41 success=yes exit=3 a0=a a1=2 a2=0 a3=7ffc9a8c3360 items=0 ppid=1022 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.764:25972): avc:  denied  { create } for  pid=1023 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.765:25973): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.765:25973): arch=c000003e syscall=4 success=yes exit=0 a0=7f22154460c1 a1=7f22110523f0 a2=7f22110523f0 a3=3 items=0 ppid=1022 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.765:25973): avc:  denied  { getattr } for  pid=1023 comm="testapp" path="/etc/resolv.conf" dev="dm-0" ino=67445450 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:net_conf_t:s0 tclass=file permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.765:25974): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.765:25974): arch=c000003e syscall=2 success=yes exit=3 a0=7f22154460c1 a1=80000 a2=1b6 a3=24 items=0 ppid=1022 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.765:25974): avc:  denied  { open } for  pid=1023 comm="testapp" path="/etc/resolv.conf" dev="dm-0" ino=67445450 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:net_conf_t:s0 tclass=file permissive=1
type=AVC msg=audit(1552588580.765:25974): avc:  denied  { read } for  pid=1023 comm="testapp" name="resolv.conf" dev="dm-0" ino=67445450 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:net_conf_t:s0 tclass=file permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.765:25975): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.765:25975): arch=c000003e syscall=42 success=yes exit=0 a0=3 a1=7f2211053dcc a2=10 a3=7f22110507a0 items=0 ppid=1 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.765:25975): avc:  denied  { connect } for  pid=1023 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.766:25976): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.766:25976): arch=c000003e syscall=16 success=yes exit=0 a0=3 a1=541b a2=7f2211050ea0 a3=7f22110507a0 items=0 ppid=1 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.766:25976): avc:  denied  { getattr } for  pid=1023 comm="testapp" path="socket:[1181449]" dev="sockfs" ino=1181449 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.769:25977): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.769:25977): arch=c000003e syscall=41 success=yes exit=3 a0=2 a1=1 a2=6 a3=7ffc9a8c35e0 items=0 ppid=1 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.769:25977): avc:  denied  { create } for  pid=1023 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.769:25978): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.769:25978): arch=c000003e syscall=42 success=no exit=-115 a0=3 a1=7ffc9a8c38d0 a2=10 a3=7ffc9a8c31e0 items=0 ppid=1 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.769:25978): avc:  denied  { name_connect } for  pid=1023 comm="testapp" dest=80 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:http_port_t:s0 tclass=tcp_socket permissive=1
type=AVC msg=audit(1552588580.769:25978): avc:  denied  { connect } for  pid=1023 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.881:25982): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.881:25982): arch=c000003e syscall=55 success=yes exit=0 a0=3 a1=1 a2=4 a3=7ffc9a8c3b20 items=0 ppid=1 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.881:25982): avc:  denied  { getopt } for  pid=1023 comm="testapp" laddr=10.0.1.10 lport=57036 faddr=5.9.243.187 fport=80 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
----
time->Thu Mar 14 14:36:20 2019
type=PROCTITLE msg=audit(1552588580.881:25983): proctitle="/usr/local/sbin/testapp"
type=SYSCALL msg=audit(1552588580.881:25983): arch=c000003e syscall=52 success=yes exit=0 a0=3 a1=7ffc9a8c39f0 a2=7ffc9a8c39ec a3=7ffc9a8c3460 items=0 ppid=1 pid=1023 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1552588580.881:25983): avc:  denied  { getattr } for  pid=1023 comm="testapp" laddr=10.0.1.10 lport=57036 faddr=5.9.243.187 fport=80 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
-----



== Section 2: Creating a credential

Credentials are utilized by Ansible Tower for authentication when launching jobs against machines,
synchronizing with inventory sources, and importing project content from a version control system.

There are many link:{cred_url}[types of credentials] including machine, network, and various cloud providers.  In this workshop, we are using a *machine* credential.


=== Step 1: Select Credentials
Select CREDENTIALS, from the left-side menu bar.   image:at_credentials.png[Cred,100,35]

=== Step 2: Select Add

Select ADD   image:at_add.png[Add,35,25]

=== Step 3: Complete the Ansible Tower Credentials form

Complete the form, using the following entries and your private Ansible Tower SSH key.  When you paste the key in the `PRIVATE KEY` field, make sure to include the `-----BEGIN RSA PRIVATE KEY-----` and `-----BEGIN RSA PRIVATE KEY-----` lines.

----
unsetopt prompt_cr prompt_sp
cat ~/.ssh/{{< span2 "prefix" "example" "-tower" >}} && echo
----

|===
|NAME |Ansible Workshop Credential
|DESCRIPTION|Machine credential for run job templates during workshop
|ORGANIZATION|Default
|TYPE|Machine
|USERNAME| ec2-user
|PRIVILEGE ESCALATION|Sudo
|PRIVATE KEY|paste in secret key
|===



image::at_cred_detail.png[Cred_Detail, 900,caption="Figure 5: ",title="Adding a Credential"]



=== Step 4: Save

Select SAVE  image:at_save.png[Save,35,25] +



== Section 3: Creating a Project

A Project is a logical collection of Ansible playbooks, represented in Ansible Tower.
You can manage playbooks and playbook directories, by either placing them manually
under the Project Base Path on your Ansible Tower server, or by placing your playbooks into
a source code management (SCM) system supported by Ansible Tower, including Git, Subversion, and Mercurial.

=== Step 1: Open a new project

Select PROJECTS image:at_projects.png[projects,125,35].

=== Step 2: Add the project

Select ADD   image:at_add.png[Add,35,25]

=== Step 3: Complete the Project form

Complete the form using the following entries:

|===
|NAME |Ansible Workshop Project
|DESCRIPTION|workshop playbooks
|ORGANIZATION|Default
|SCM TYPE|Git
|SCM URL| https://github.com/ansible/lightbulb
|SCM BRANCH|
|SCM UPDATE OPTIONS
a|

- [*] Clean
- [*] Delete on Update
- [*] Update on Launch
|===



image::at_project_detail.png[Cred_Detail, 900,caption="Figure 6: ",title="Defining a Project"]



=== Step 4: Save

Select SAVE image:at_save.png[Save,35,25]




== Section 4: Creating an Inventory

An inventory is a collection of hosts, against which jobs may be launched.
Inventories are divided into groups and these groups contain the actual hosts.

Groups may be sourced *manually*, by entering host names into Ansible Tower, or from one of Ansible Tower’s supported cloud providers.

An Inventory can also be *imported* into Ansible Tower using the `tower-manage` command. This is how we are going to add an inventory for this workshop.


=== Step 1: Navigate to Inventories main link

Select INVENTORIES    image:at_inv_icon.png[Inv, 100,30]

=== Step 2: Add a new inventory

Select ADD image:at_add.png[Add,35,25], and then select Inventory.

=== Step 3: Complete the Inventory form

Complete the form, using the following entries:

|===
|NAME |Ansible Workshop Inventory
|DESCRIPTION|workshop hosts
|ORGANIZATION|Default
|===



image::at_inv_create.png[Cred_Detail,900,caption="Figure 7: ",title="Create an Inventory"]



=== Step 4: Save

Select SAVE  image:at_save.png[Save,35,25]

=== Step 5: Switch back to your terminal session

Switch back to your terminal session.  If by any chance you closed the wetty browser window, open a new one with the URL shown, below:

[source,bash]
----
{{< urifqdn "https://" "tower" ":8888/wetty/ssh/ec2-user" >}}
----




=== Step 6: Import an existing inventory

Use the `tower-manage` command to import an existing inventory.  (_Be sure to replace <username> with your actual username._)
----
sudo tower-manage inventory_import --source=/home/ec2-user/hosts --inventory-name="Ansible Workshop Inventory"
----

You should see output similar to the following:



image::at_tm_stdout.png[Cred_Detail,900,caption="Figure 8: ",title="Importing an inventory with tower-manage"]




Feel free to browse your inventory in Ansible Tower, by selecting *Hosts*. image:at_inv_hosts.png[hosts,200,50]

You should now notice that the inventory has been populated with each each of hosts and corresponding inventory.

image::at_inv_group.png[Cred_Detail,900,caption="Figure 9: ",title="Inventory with Groups"]




=== End Result

At this point, we are working with our basic configuration of Ansible Tower.  In Exercise 2.2, we will be solely focused on creating and running a job template so you can see Ansible Tower in action.

{{< importPartial "footer/footer.html" >}}
